# if statement
snippet if "if" b
if (${1}) begin
	${0}
end
endsnippet

# if/else statement
snippet ife "if/else" b
if (${1}) begin
	${2}
end
else begin
	${3}
end
endsnippet

# else if statement
snippet eif "else if" b
else if (${1}) begin
	${0}
end
endsnippet

# else statement
snippet el "else" b
else begin
	${0}
end
endsnippet

# repeat loop
snippet rep "repeat" b
repeat (${1}) begin
	${0}
end
endsnippet

# case statement
snippet case "case" b
case (${1:/* Variable */})
	${2:/* value */}: begin
		${3}
	end
	default: begin
		${4}
	end
endcase
endsnippet

# always combinational block
snippet al "always *" b
always @(*) begin
	${1}
end
endsnippet

# always sequential block: pos clk
snippet alp "always pos clk" b
always @(posedge ${1:i_clk}) begin
	${0}
end
endsnippet

# always sequential block: pos clk neg rst
snippet alpn "always pos clk neg rst" b
always @(posedge ${1:clk} or negedge ${2:rst_n}) begin
	if (!$2) begin
		${0}
	end
	else begin
	end
end
endsnippet

# always sequential block: pos clk pos rst
snippet alpp "always pos clk pos rst" b
always @(posedge ${1:clk} or posedge ${2:rst}) begin
	if ($2) begin
		${0}
	end
	else begin
	end
end
endsnippet

# generate
snippet gen "generate" b
generate
${0}
endgenerate
endsnippet

# module block
snippet mod "module" b
module ${1:name} (
	${0}
);

\`protect


\`endprotect

endmodule // $1
endsnippet

# for
snippet for "for" b
for (${1:i}; $1<${2:count}; $1=$1+${3:1})
	${4}
end
endsnippet

# while
snippet wh "while" b
while (${1}) begin
	${2}
end
endsnippet

# function
snippet func "function" b
function ${1:void} ${2:name}({3});
	${0}
endfunction: $2
endsnippet

# task
snippet task "task" b
task ${1:name}({2});
	${0}
endtask: $1
endsnippet

# initial
snippet ini "initial" b
initial begin
	${0}
end
endsnippet

# typedef struct packed
snippet tdsp "typedef struct packed" b
typedef struct packed {
	int ${2:data};
} ${1:`vim_snippets#Filename('$1_t', 'name')`};
endsnippet

# typedef enum
snippet tde "typedef enum" b
typedef enum ${2:logic[15:0]} {
	${3:REG = 16'h0000'}
} ${1:my_dest_t};
endsnippet

# timescale
snippet ts "timescale" b
\`timescale ${1:1ns}/${2:10ps}${0}
endsnippet

# include
snippet inc "include" b
\`include "${1}"${0}
endsnippet

# define
snippet def "define" b
\`define ${1} ${2}
endsnippet

# ifdef
snippet ifd "ifdef" b
\`ifdef ${1:TARGET}
${0}
\`endif // $1
endsnippet

# ifdef/else
snippet ifde "ifdef/else" b
	\`ifdef ${1:TARGET}
	${0}
	\`else // $1
	\`endif // $1
endsnippet

# begin end
snippet beg "begin end" w
begin
	${1}
end
endsnippet

# reg dq
snippet rdq "ff dq" b
reg ${1:#:nbit}${2:reg}_q, $2_d;${0}
endsnippet

# input port
snippet inp "input port" b
input ${1:nbit} i_${2:port},${0}
endsnippet

# output port
snippet out "output port" b
output ${1:nbit} o_${2:port},${0}
endsnippet

# in/out port
snippet ino "in/out port" b
inout ${1:nbit} io_${2:port},${0}
endsnippet

# reg sequential
snippet as< "reg sequential" b
${1:reg}_q <= ${2:delay} $1_d;${0}
endsnippet

# reg keep
snippet as= "reg keep value" b
${1:reg}_d = $1_q;${0}
endsnippet

# assign
snippet as "assign" b
assign ${1:wire} = ${2:value};${0}
endsnippet

# parameter
snippet pa "parameter" b
parameter ${1:name} = ${2:value};${0}
endsnippet

# localparam
snippet lpa "localparam" b
localparam ${1:name} = ${2:value};${0}
endsnippet

# dumpfile
snippet df "dumpfile" b
$dumpfile("${1:`expand("%:r")`}.fsdb");${0}
endsnippet

# dumpvars
snippet dv "dumpvars" b
$dumpvars(${1:0}, ${2:`expand("%:r")`});${0}
endsnippet

# display
snippet display "display" b
$display("${1}", ${2});
endsnippet

# strobe
snippet strobe "strobe" b
$strobe("${1}", ${2});
endsnippet

# parameterized bit operand: 0
snippet p0
{(${1:pwidth}){1'b0}}
endsnippet

# parameterized bit operand: 1
snippet p1
{{(${1:pwidth}-1){1'b0}},1'b1}
endsnippet

# vim:foldmethod=marker
