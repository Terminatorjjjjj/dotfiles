
" Runtime Path: {{{
set runtimepath+=~/.vim/bundle/supertab " ervandew/supertab
set runtimepath+=~/.vim/bundle/vim-easy-align " junegunn/vim-easy-align
set runtimepath+=~/.vim/bundle/rainbow_parentheses.vim " kien/rainbow_parentheses.vim
set runtimepath+=~/.vim/bundle/VisIncr " vim-scripts/VisIncr
set runtimepath+=~/.vim/bundle/ultisnips " SirVer/ultisnips
set runtimepath+=~/.vim/bundle/vim-unimpaired " tpope/vim-unimpaired
set runtimepath+=~/.vim/bundle/ctrlp.vim " ctrlpvim/ctrlp.vim

set runtimepath^=~/.vim/bundle/tabular " godlygeek/tabular
set runtimepath^=~/.vim/bundle/auto_pairs " jiangmiao/auto-pairs
set runtimepath^=~/.vim/bundle/nerdtree " preservim/nerdtree
set runtimepath+=~/.vim/bundle/limelight " junegunn/limelight.vim
set runtimepath+=~/.vim/bundle/vim-fugitive " tpope/vim-fugitive
set runtimepath+=~/.vim/bundle/rainbow_parentheses.vim " kien/rainbow_parentheses.vim

" }}}

" Plugin: NerdTree {{{

nnoremap <silent> <C-n> :NERDTreeToggle<CR>
nnoremap <leader>nr :NERDTreeRefreshRoot<CR>

let NERDTreeShowHidden=1
let NERDTreeQuitOnOpen=1
let NERDTreeWinPos='right'
let NERDTreeMinimalUI=1
let g:NERDTreeWinSize=20

" go to tab if already exist
function! NERDTreeMyOpenInTab(node)
   call a:node.open({'reuse': "all", 'where': 't'})
endfunction
autocmd VimEnter * :call NERDTreeAddKeyMap({'key':'t', 'callback':'NERDTreeMyOpenInTab', 'scope':'FileNode', 'override':1})

" start NERDTree when Vim is started without file arguments.
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc()==0 && !exists('s:std_in') | NERDTree | endif

" exit Vim if NERDTree is the only window remaining in the only tab.
autocmd BufEnter * if tabpagenr('$')==1 && winnr('$')==1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | q | endif

" close the tab if NERDTree is the only window remaining in it.
autocmd BufEnter * if winnr('$')==1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | q | endif

" open the existing NERDTree on each new tab.
autocmd BufWinEnter * if getcmdwintype()=='' | silent NERDTreeMirror | endif

" augroup number_toggle
"    autocmd!
"    autocmd BufEnter,FocusGained,InsertLeave * if &ft!="nerdtree" | set relativenumber | endif
"    autocmd BufLeave,FocusLost,InsertEnter   * set norelativenumber
" augroup END

" }}}
" Plugin: Tabular {{{

nnoremap <Leader>t :Tabularize /
vnoremap <Leader>t :Tabularize /

" }}}
" Plugin: Limelight {{{

" toggle limelight
nnoremap gll :Limelight!!<cr>
" config color for unfocuesed part (for gruvbox)
let g:limelight_conceal_ctermfg=241
let g:limelight_conceal_guifg='#665c54'

"  }}}
" Plugin: Fugitive {{{

" select from target (left)
nnoremap gh[ :diffget //2<CR> :diffupdate<CR>
" select from merge (right)
nnoremap gh] :diffget //3<CR> :diffupdate<CR>

" }}}
" Plugin: Rainbow Parentheses {{{

" augroup rainbow_parenthesis
"     autocmd!
"     autocmd VimEnter * RainbowParenthesesToggle
"     autocmd Syntax * RainbowParenthesesLoadRound
"     autocmd Syntax * RainbowParenthesesLoadSquare
"     autocmd Syntax * RainbowParenthesesLoadBraces
" augroup END

" }}}

" Quickfix List {{{
function! QuickFixMapping()
    " go to next location and stay in quick fix window
    nnoremap <buffer> j :cnext<cr>zz<c-w>w
    " go to prev location and stay in quick fix window
    nnoremap <buffer> k :cprev<cr>zz<c-w>w
endfunction

augroup quickfix_group
    autocmd!
    autocmd Filetype quickfix call QuickFixMapping()
augroup END

" }}}

