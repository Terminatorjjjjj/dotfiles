
" Runtime Path: {{{
set runtimepath+=~/.vim/bundle/ervandew/supertab
set runtimepath+=~/.vim/bundle/junegunn/vim-easy-align
set runtimepath+=~/.vim/bundle/vim-scripts/VisIncr
set runtimepath+=~/.vim/bundle/SirVer/ultisnips
set runtimepath+=~/.vim/bundle/tpope/vim-unimpaired
set runtimepath+=~/.vim/bundle/ctrlpvim/ctrlp.vim

set runtimepath^=~/.vim/bundle/godlygeek/tabular
set runtimepath^=~/.vim/bundle/jiangmiao/auto-pairs
set runtimepath^=~/.vim/bundle/preservim/nerdtree
set runtimepath+=~/.vim/bundle/junegunn/limelight.vim
set runtimepath+=~/.vim/bundle/tpope/vim-fugitive
set runtimepath+=~/.vim/bundle/kien/rainbow_parentheses.vim

" }}}

" Plugin: NerdTree {{{

nnoremap <silent> <C-n> :NERDTreeToggle<CR>
nnoremap <leader>nr :NERDTreeRefreshRoot<CR>

let NERDTreeShowHidden=1
let NERDTreeQuitOnOpen=1
let NERDTreeWinPos='right'
let NERDTreeMinimalUI=1
let g:NERDTreeWinSize=20

" go to tab if already exist
function! NERDTreeMyOpenInTab(node)
   call a:node.open({'reuse': "all", 'where': 't'})
endfunction
autocmd VimEnter * :call NERDTreeAddKeyMap({'key':'t', 'callback':'NERDTreeMyOpenInTab', 'scope':'FileNode', 'override':1})

" start NERDTree when Vim is started without file arguments.
autocmd StdinReadPre * let s:std_in=1
autocmd VimEnter * if argc()==0 && !exists('s:std_in') | NERDTree | endif

" exit Vim if NERDTree is the only window remaining in the only tab.
autocmd BufEnter * if tabpagenr('$')==1 && winnr('$')==1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | q | endif

" close the tab if NERDTree is the only window remaining in it.
autocmd BufEnter * if winnr('$')==1 && exists('b:NERDTree') && b:NERDTree.isTabTree() | q | endif

" open the existing NERDTree on each new tab.
autocmd BufWinEnter * if getcmdwintype()=='' | silent NERDTreeMirror | endif

" augroup number_toggle
"    autocmd!
"    autocmd BufEnter,FocusGained,InsertLeave * if &ft!="nerdtree" | set relativenumber | endif
"    autocmd BufLeave,FocusLost,InsertEnter   * set norelativenumber
" augroup END

" }}}
" Plugin: Tabular {{{

nnoremap <Leader>t :Tabularize /
vnoremap <Leader>t :Tabularize /

" }}}
" Plugin: Limelight {{{

" toggle limelight
nnoremap gll :Limelight!!<cr>
" config color for unfocuesed part (for gruvbox)
let g:limelight_conceal_ctermfg=241
let g:limelight_conceal_guifg='#665c54'

"  }}}
" Plugin: Fugitive {{{

" select from target (left)
nnoremap gh[ :diffget //2<CR> :diffupdate<CR>
" select from merge (right)
nnoremap gh] :diffget //3<CR> :diffupdate<CR>

" }}}
" Plugin: Rainbow Parentheses {{{

" augroup rainbow_parenthesis
"     autocmd!
"     autocmd VimEnter * RainbowParenthesesToggle
"     autocmd Syntax * RainbowParenthesesLoadRound
"     autocmd Syntax * RainbowParenthesesLoadSquare
"     autocmd Syntax * RainbowParenthesesLoadBraces
" augroup END

" }}}
" Plugin: Ultisnips {{{

" vim with python3 support is required
" a link to ultisnips/ftdetect is required under ./vim/ftdetect
" in runtimepath, path to supertab must come before ultisnips
let g:UltiSnipsSnippetsDir = "~/.vim/my_snippet"
let g:UltiSnipsSnippetDirectories = ["ulti_snippet", "my_snippet"]
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

" }}}
" Plugin: Supertab {{{

let g:SuperTabMappingForward = '<tab>' " default
let g:SuperTabMappingBackward = '<s-tab>' " default

" }}}

" Quickfix List {{{
function! QuickFixMapping()
    " go to next location and stay in quick fix window
    nnoremap <buffer> j :cnext<cr>zz<c-w>w
    " go to prev location and stay in quick fix window
    nnoremap <buffer> k :cprev<cr>zz<c-w>w
endfunction

augroup quickfix_group
    autocmd!
    autocmd Filetype quickfix call QuickFixMapping()
augroup END

" }}}

