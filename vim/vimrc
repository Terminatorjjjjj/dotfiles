set nocompatible " must be first

"  PLUGIN RUNTIME PATH {{{
" -----------------------------------------------------------------------------
set runtimepath+=~/.vim/bundle/supertab " ervandew/supertab
set runtimepath+=~/.vim/bundle/vim-easy-align " junegunn/vim-easy-align
set runtimepath+=~/.vim/bundle/rainbow_parentheses.vim " kien/rainbow_parentheses.vim
set runtimepath+=~/.vim/bundle/VisIncr " vim-scripts/VisIncr
set runtimepath+=~/.vim/bundle/ultisnips " SirVer/ultisnips
set runtimepath+=~/.vim/bundle/vim-unimpaired " tpope/vim-unimpaired
set runtimepath+=~/.vim/bundle/vim-fugitive " tpope/vim-fugitive
set runtimepath+=~/.vim/bundle/ctrlp.vim " ctrlpvim/ctrlp.vim
" }}}

"  BASIC SETTING {{{
" -----------------------------------------------------------------------------
syntax enable
syntax on
filetype on
filetype plugin indent on

set autoindent smartindent
set backspace=2
set expandtab softtabstop=-1 " use shiftwidth
set tabstop=8
set shiftwidth=4
set ruler
set showcmd
set nowrap
set incsearch
set cursorline cursorcolumn
autocmd WinEnter * setlocal cursorline cursorcolumn
autocmd WinLeave * setlocal nocursorline nocursorcolumn
" }}}

"  MORE SETTING {{{
" -----------------------------------------------------------------------------
" do not redraw screen in the middle of the macro
set lazyredraw
" disable linebreak word wrap in insert mode
set formatoptions-=t
" persistent undo
set undofile
set history=50
set autochdir
set splitbelow splitright

set number relativenumber
augroup number_toggle
    autocmd!
    autocmd BufEnter,FocusGained,InsertLeave * set relativenumber
    autocmd BufLeave,FocusLost,InsertEnter * set norelativenumber
augroup END

augroup autocomplete_ignore_case
    autocmd!
    autocmd InsertLeave * set noignorecase
    autocmd InsertEnter * set ignorecase
augroup END

set backupdir=.vi_backup/,~/.vi_backup/,/tmp//
set directory=.vi_swp/,~/.vi_swp/,/tmp//
set undodir=.vi_undo/,~/.vi_undo/,/tmp//

" vertically center document when entering insert mode
augroup vertical_center_insert
    autocmd!
    autocmd InsertEnter * normal zz
augroup END

" make shell not source startup scripts when running shell command in vim
set shellcmdflag=-f\ -c
" }}}

"  WILDMENU {{{
"  enable auto completion menu w/ tab & behave like bash
" -----------------------------------------------------------------------------
set wildmenu
set wildmode=list:longest,full
set wildignore=*.docx,*.jpg,*.png,*.gif,*.pdf,*.pyc,*.exe,*.flv,*.img,*.xlsx,*.zip,*.so,*.swp,*/tmp/*
" }}}

"  FILE TYPE {{{
" -----------------------------------------------------------------------------
augroup set_file_type
    autocmd!
    autocmd BufNewFile,BufRead .bashrc*,bashrc,.bash_profile*,bash_profile* setfiletype sh
    autocmd BufNewFile,BufRead *.v,*.vh,*.vs setfiletype systemverilog
    autocmd BufNewFile,BufRead *.sv,*.svh    setfiletype systemverilog
    autocmd BufNewFile,BufRead *.v,*.vh,*.vs set syntax=systemverilog
    autocmd BufNewFile,BufRead *.sv,*.svh    set syntax=systemverilog
augroup END

" filename suffix for 'gf' keymap to search in path
augroup set_suffixesadd
    autocmd!
    autocmd Filetype systemverilog setlocal suffixesadd+=.v,.sv,.h,.svh
augroup END
" }}}

"  COLORSCHEME {{{
" -----------------------------------------------------------------------------
set background=dark
colorscheme gruvbox
" }}}

"  STATUSLINE {{{
" -----------------------------------------------------------------------------
function! Gitbranch()
    return trim(system("git -C " . expand("%:h") . " branch --show-current 2>/dev/null"))
endfunction

augroup Gitget
    autocmd!
    autocmd BufEnter * let b:git_branch = Gitbranch()
augroup END

au InsertEnter * hi statusline cterm=standout
au InsertLeave * hi statusline cterm=none ctermfg=243 ctermbg=235
hi statusline cterm=none ctermfg=243 ctermbg=235

set laststatus=2
set statusline=
set statusline+=%0*\ %{fugitive#statusline()}
" set statusline+=%0*\ [Git(%{b:git_branch})]
set statusline+=%0*\ %y\        " file type
set statusline+=%1*\ %f         " file name; .50F: full file path w/ 50 char max
set statusline+=%1*\ %r\ %m     " read only; modified
set statusline+=%=              " switch to right region
set statusline+=%1*\ %p%%       " percentage
set statusline+=%1*\ [%c:%l/%L] " columen; line; total lines

hi User1 cterm=none ctermfg=243 ctermbg=235
" }}}

"  KEY BINDING {{{
" -----------------------------------------------------------------------------
let mapleader='\'

inoremap jj <esc>
nnoremap <space> :
vnoremap <space> :

nnoremap Y y$
nnoremap gw <c-w>

" move line up/down (add ==, ==gi, gv=gv if want auto align indent)
nnoremap <c-j> :m .+1<cr>
nnoremap <c-k> :m .-2<cr>
inoremap <c-j> <esc>:m .+1<cr>gi
inoremap <c-k> <esc>:m .-2<cr>gi
vnoremap <c-j> :m '>+1<cr>gv
vnoremap <c-k> :m '<-2<cr>gv

" add semicolon to the end of current line w/o moving cursor
nnoremap <leader>; m'a;<esc>`'

" close terminal mode (only supported in vim8)
if v:version > 800
    tnoremap <esc> <c-\><c-n>:q!<cr>
endif

" keeping search result centered
nnoremap N Nzzzv
nnoremap n nzzzv

" horizontal movement w/ easier pressing
nnoremap H ^
nnoremap L $

" go to prev match history in command line
cnoremap <c-j> <down>
cnoremap <c-k> <up>

" replace the word under cursor
nnoremap <leader>* :%s/\<<c-r><c-w>\>//g<left><left>

" nnoremap gp :find<space>*
" }}}

"  CODE COMMENT {{{
" -----------------------------------------------------------------------------
augroup comment_group_of_code
    autocmd!
    autocmd FileType c,cpp,java,scala,verilog,systemverilog,fotran,stata let b:comment_leader = '// '
    autocmd FileType sh,ruby,python,make,tmux,tcsh,csh,zsh,conf          let b:comment_leader = '# '
    autocmd FileType tex,matlab                                          let b:comment_leader = '% '
    autocmd FileType vim                                                 let b:comment_leader = '" '
augroup END

" comment and uncomment
noremap <silent> gcc :<c-b>silent <c-e>s/^/<c-r>=escape(b:comment_leader,'\/')<cr>/<cr>:nohlsearch<cr>
noremap <silent> gcu :<c-b>silent <c-e>s/^\v<c-r>=escape(b:comment_leader,'\/')<cr>//e<cr>:nohlsearch<cr>

" single keymap toggle
function! CommentToggle() range
    if getline(a:firstline) =~ '^\V' . escape(b:comment_leader, '\')
        silent execute a:firstline . ',' . a:lastline . 's/^\V' . escape(b:comment_leader, '\/') . '//e'
    else
        silent execute a:firstline . ',' . a:lastline . 's/^/' . escape(b:comment_leader, '\/') . '/e'
    endif
endfunction
command! -range CT <line1>,<line2>call CommentToggle()|nohlsearch

nnoremap <c-\> :CT<cr>
vnoremap <c-\> :CT<cr>
nnoremap gci :CT<cr>
vnoremap gci :CT<cr>
" }}}

"  FOLD {{{
" -----------------------------------------------------------------------------
function! MyFoldText()
    let line = getline(v:foldstart)
    let sub1 = substitute(line, '/\*\|\*/\| {{{\d\=', '', 'g') " }}} for correct folding
    let sub2 = substitute(sub1, '^ \+', '', 'g')
    let folded_line_count = v:foldend - v:foldstart + 1
    return printf('%5d ...  %s  ...', folded_line_count, sub2)
endfunction

set foldmethod=marker
set foldmarker={{{,}}}
set foldlevel=0
set foldcolumn=0
set fillchars=fold:\  " a space after \
set foldtext=MyFoldText()

nnoremap <cr> za
vnoremap <cr> za
" }}}

"  SPLITS {{{
" -----------------------------------------------------------------------------
" move to next split
map <c-l> :wincmd w<cr>
" remove pipes | that act as separators on splits (there is a space after \)
set fillchars+=vert:\ 
" }}}

"  BUFFERS {{{
" -----------------------------------------------------------------------------
" to change buffer w/o saving current buffer
set hidden
" display buffer list and go to buffer
nnoremap gb :ls<cr>:b<space>
" display buffet list and open buffer in right split
nnoremap gs :ls<cr>:vert sb<space>
" go to last buffer
nnoremap <c-h> :b#<cr>
" }}}

"  PLUGIN: RAINBOW PARENTHESES {{{
" -----------------------------------------------------------------------------
augroup rainbow_parenthesis
    autocmd!
    autocmd VimEnter * RainbowParenthesesToggle
    autocmd Syntax * RainbowParenthesesLoadRound
    autocmd Syntax * RainbowParenthesesLoadSquare
    autocmd Syntax * RainbowParenthesesLoadBraces
augroup END
" }}}

"  PLUGIN: SUPERTAB {{{
" -----------------------------------------------------------------------------
let g:SuperTabMappingForward = '<s-tab>'
let g:SuperTabMappingBackward = '<tab>'
" }}}

"  PLUGIN: ULTISNIPS {{{
" -----------------------------------------------------------------------------
let g:UltiSnipsSnippetsDir = "~/.vim/my_snippet"
let g:UltiSnipsSnippetDirectories = ["ulti_snippet", "my_snippet"]
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
" }}}

"  PLUGIN: EASY ALIGN {{{
" -----------------------------------------------------------------------------
" start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <plug>(EasyAlign)
" start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <plug>(EasyAlign)

" verilog non-blocking auto align
inoremap <silent> <= <=<esc>mzvip:EasyAlign/<=/<cr>`z$a<space>

" customized setting mainly for verilog
" d: for aligning port/signal list with last space before ,;=)
let g:easy_align_delimiters = {
\ '/': {
\     'pattern':         '//\+\|/\*\|\*/',
\     'delimiter_align': 'l',
\     'ignore_groups':   ['!Comment'] 
\     },
\ ':': {
\     'pattern':       ':',
\     'left_margin':   1,
\     'right_margin':  1,
\     },
\ '?': {
\     'pattern':       '?',
\     'left_margin':   1,
\     'right_margin':  1,
\     },
\ '(': {
\     'pattern':       '(',
\     'left_margin':   1,
\     'right_margin':  0,
\   },
\ ')': {
\     'pattern':       ')',
\     'left_margin':   0,
\     'right_margin':  0,
\   },
\ 'd': {
\     'pattern':      ' \ze\S\+\s*[,;=]',
\     'left_margin':  0,
\     'right_margin': 0
\   }
\ }
" }}}

"  PLUGIN: FUGITIVE {{{
" -----------------------------------------------------------------------------
" select from target (left)
nnoremap gh[ :diffget //2<cr> :diffupdate<cr>
" select from merge (right)
nnoremap gh] :diffget //3<cr> :diffupdate<cr>
" }}}

"  PLUGIN: CTRLP {{{
" -----------------------------------------------------------------------------
let g:ctrlp_map = '<c-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_show_hidden = 0
let g:ctrlp_user_command = {
\ 'types': {
\     1: ['.git', 'cd %s && git ls-files'],
\     2: ['.hg', 'hg --cwd %s locate -I .'],
\     },
\ 'fallback': 'find %s -type f'
\ }

nnoremap gp :CtrlPBuffer<cr>
"  }}}

" modeline
" vim:foldmethod=marker:foldmarker={{{,}}}:foldlevel=0:
