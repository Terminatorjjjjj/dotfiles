set nocompatible " must be first

" Runtime Path: {{{

set runtimepath+=~/.vim/bundle/supertab " ervandew/supertab
set runtimepath+=~/.vim/bundle/vim-easy-align " junegunn/vim-easy-align
set runtimepath+=~/.vim/bundle/rainbow_parentheses.vim " kien/rainbow_parentheses.vim
set runtimepath+=~/.vim/bundle/VisIncr " vim-scripts/VisIncr
set runtimepath+=~/.vim/bundle/ultisnips " SirVer/ultisnips
set runtimepath+=~/.vim/bundle/vim-unimpaired " tpope/vim-unimpaired
set runtimepath+=~/.vim/bundle/ctrlp.vim " ctrlpvim/ctrlp.vim

" }}}
" Basic Setting: {{{

syntax enable
syntax on
filetype on
filetype plugin indent on

set autoindent smartindent
set backspace=2
set expandtab softtabstop=-1 " use shiftwidth
set tabstop=8
set shiftwidth=4
set ruler
set showcmd
set nowrap
set incsearch hlsearch
set cursorline
set number relativenumber
set wildmenu
set laststatus=2

" }}}
" More Setting: {{{

" do not redraw screen in the middle of the macro
set lazyredraw
" disable linebreak word wrap in insert mode
set formatoptions-=t
" persistent undo
set undofile
set autochdir
set splitbelow splitright

augroup cursor_toggle
    autocmd!
    autocmd WinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
augroup END

augroup cursor_insert
    autocmd!
    autocmd InsertEnter * setlocal cursorcolumn
    autocmd InsertLeave * setlocal nocursorcolumn
augroup END

augroup number_toggle
    autocmd!
    autocmd BufEnter,FocusGained,InsertLeave * set relativenumber
    autocmd BufLeave,FocusLost,InsertEnter * set norelativenumber
augroup END

augroup autocomplete_ignore_case
    autocmd!
    autocmd InsertEnter * set ignorecase
    autocmd InsertLeave * set noignorecase
augroup END

set backupdir=.vi_backup/,~/.vi_backup/,/tmp//
set directory=.vi_swp/,~/.vi_swp/,/tmp//
set undodir=.vi_undo/,~/.vi_undo/,/tmp//

" vertically center document when entering insert mode
augroup vertical_center_insert
    autocmd!
    autocmd InsertEnter * normal zz
augroup END

" make shell not source startup scripts when running shell command in vim
set shellcmdflag=-f\ -c

" }}}
" Wild Menu: {{{

" enable auto completion menu w/ tab & behave like bash
set wildmode=list:longest,full
set wildignore=*.docx,*.jpg,*.png,*.gif,*.pdf,*.pyc,*.exe,*.flv,*.img,*.xlsx,*.zip,*.so,*.swp,*/tmp/*,*/.git/*

" }}}
" File Type: {{{

augroup set_file_type
    autocmd!
    autocmd BufNewFile,BufRead .bashrc*,bashrc,.bash_profile*,bash_profile* setfiletype sh
    autocmd BufNewFile,BufRead *.v,*.vh,*.vs setfiletype systemverilog
    autocmd BufNewFile,BufRead *.sv,*.svh    setfiletype systemverilog
    autocmd BufNewFile,BufRead *.v,*.vh,*.vs set syntax=systemverilog
    autocmd BufNewFile,BufRead *.sv,*.svh    set syntax=systemverilog
augroup END

" filename suffix for 'gf' keymap to search in path
augroup set_suffixesadd
    autocmd!
    autocmd Filetype systemverilog setlocal suffixesadd+=.v,.sv,.h,.svh
augroup END

" }}}

" Colorscheme: {{{

set background=dark
colorscheme gruvbox

hi CursorLine ctermbg=233
hi CursorLineNr ctermbg=233

" }}}
" Status Line: {{{

" modified from this blog:
"   https://jip.dev/posts/a-simpler-vim-statusline/
"   https://github.com/blaenk/dots/blob/dfb34f1ad78f5aa25bc486d3c14c9a0ef24094bd/vim/.vimrc#L168

function! Status(winnum) abort
    let active = a:winnum == winnr()
    let bufnum = winbufnr(a:winnum)

    function! Color(active, num, content)
        if a:active
            " output the content with supplied colorgroup num, e.g. num=1 -> User1
            return '%' . a:num. '*' . a:content . '%*'
        else
            return a:content
        endif
    endfunction

    function! GitBranch()
        let br = trim(system("git -C " . expand("%:h") . " branch --show-current 2>/dev/null")) 
        if strlen(br) > 0
            return ' ' . br
        else
            return ''
    endfunction

    let fill = (active) ? '%6*' : ''
    let buftype = getbufvar(bufnum, '&buftype')
    let bufname = bufname(bufnum)

    " handlftype alternative statusline
    if buftype ==# 'help'
        let helpname = ' ' . fnamemodify(bufname, ':t:r')
        let altstat = Color(active, 6, ' »')
        let altstat .= Color(active, 5, helpname)
        let altstat .= Color(active, 6, ' «')
        let altstat .= fill
        return altstat
    endif

    let branch = (active) ? GitBranch() : ''
    let separator = (strlen(branch)>0) ? ' »' : ''
    let filename = ' %<%f'
    let readonly = getbufvar(bufnum, '&readonly') ? ' ‼' : ''
    let modified = getbufvar(bufnum, '&modified') ? ' +' : ''
    let column = '%c '

    let stat = ''
    let stat .= Color(active, 1, branch)
    let stat .= Color(active, 6, separator)
    let stat .= Color(active, 2, filename)
    let stat .= Color(active, 6, ' »')
    let stat .= fill
    let stat .= Color(active, 3, readonly)
    let stat .= Color(active, 3, modified)
    let stat .= fill
    let stat .= '%='
    let stat .= Color(active, 6, '« ')
    let stat .= fill
    let stat .= Color(active, 4, column)
    let stat .= fill . ' '

    return stat
endfunction

function! s:RefreshStatus()
  for nr in range(1, winnr('$'))
    call setwinvar(nr, '&statusline', '%!Status(' . nr . ')')
  endfor
endfunction

" TODO: when <C-w>o to close all other windows, current statusline becomes default
augroup status
  autocmd!
  autocmd VimEnter,WinEnter,BufWinEnter * call <SID>RefreshStatus()
augroup END

hi link User1 Identifier
hi link User2 String
hi link User3 Number
hi link User4 Identifier
hi link User5 Normal
hi link User6 Comment
" hi! link StatusLineNC Comment

" }}}
" Key Binding: {{{

let mapleader='\'

inoremap jj <Esc>
nnoremap <Space> :
vnoremap <Space> :

nnoremap Y y$
nnoremap gw <C-w>

" move line up/down (add ==, ==gi, gv=gv if want auto align indent)
nnoremap <C-j> :m .+1<CR>
nnoremap <C-k> :m .-2<CR>
inoremap <C-j> <Esc>:m .+1<CR>gi
inoremap <C-k> <Esc>:m .-2<CR>gi
vnoremap <C-j> :m '>+1<CR>gv
vnoremap <C-k> :m '<-2<CR>gv

" add semicolon to the end of current line w/o moving cursor
nnoremap <leader>; m'a;<Esc>`'

" close terminal mode (only supported in vim8)
if v:version > 800
    tnoremap <Esc> <C-\><C-n>:q!<CR>
endif

" keeping search result centered
nnoremap N Nzzzv
nnoremap n nzzzv

" horizontal movement w/ easier pressing
nnoremap H ^
nnoremap L $

" go to prev match history in command line
cnoremap <C-j> <down>
cnoremap <C-k> <up>

" replace the word under cursor
nnoremap gcr :%s/\<<C-r><C-w>\>//g<left><left>

" nnoremap gp :find<Space>*

" remap since ; is used for fold toggle
nnoremap <Space>; ;

" }}}
" Code Comment: {{{

augroup get_comment_leader
    autocmd!
    autocmd FileType c,cpp,java,scala,verilog,systemverilog,fotran,stata let b:comment_leader = '// '
    autocmd FileType sh,ruby,python,make,tmux,tcsh,csh,zsh,conf          let b:comment_leader = '# '
    autocmd FileType tex,matlab                                          let b:comment_leader = '% '
    autocmd FileType vim                                                 let b:comment_leader = '" '
augroup END

" comment and uncomment
noremap <silent> gcc :<C-b>silent <C-e>s/^/<C-r>=escape(b:comment_leader,'\/')<CR>/<CR>:nohlsearch<CR>
noremap <silent> gcu :<C-b>silent <C-e>s/^\v<C-r>=escape(b:comment_leader,'\/')<CR>//e<CR>:nohlsearch<CR>

" single keymap toggle
function! CommentToggle() range
    if getline(a:firstline) =~ '^\V' . escape(b:comment_leader, '\')
        silent execute a:firstline . ',' . a:lastline . 's/^\V' . escape(b:comment_leader, '\/') . '//e'
    else
        silent execute a:firstline . ',' . a:lastline . 's/^/' . escape(b:comment_leader, '\/') . '/e'
    endif
endfunction
command! -range CT <line1>,<line2>call CommentToggle()|nohlsearch

nnoremap <silent> gci :CT<CR>
vnoremap <silent> gci :CT<CR>

" }}}
" Fold: {{{

function! MyFoldText()
    let line = getline(v:foldstart)
    let sub1 = substitute(line, '/\*\|\*/\| {{{\d\=', '', 'g') " }}} for correct folding
    let sub2 = substitute(sub1, '^ \+', '', 'g')
    let folded_line_count = v:foldend - v:foldstart + 1
    return printf('··· %4d   %s  ', folded_line_count, sub2)
endfunction

set foldmethod=marker
set foldmarker={{{,}}}
set foldlevel=0
set foldcolumn=0
set fillchars=fold:\·
set foldtext=MyFoldText()

hi! link Folded Comment

nnoremap ; za
vnoremap ; za

" }}}
" Splits: {{{

" move to next split
map <C-l> <C-w>w
" remove pipes | that act as separators on splits (there is a space after \)
set fillchars+=vert:\ 

" }}}
" Buffers: {{{

" to change buffer w/o saving current buffer
set hidden
" display buffer list and go to buffer
nnoremap gb :ls<CR>:b<Space>
" display buffet list and open buffer in right split
nnoremap gs :ls<CR>:vert sb<Space>
" go to last buffer
nnoremap <C-h> :b#<CR>

" }}}

" Plugin: Rainbow Parentheses {{{

augroup rainbow_parenthesis
    autocmd!
    autocmd VimEnter * RainbowParenthesesToggle
    autocmd Syntax * RainbowParenthesesLoadRound
    autocmd Syntax * RainbowParenthesesLoadSquare
    autocmd Syntax * RainbowParenthesesLoadBraces
augroup END

" }}}
" Plugin: Supertab {{{

let g:SuperTabMappingForward = '<s-tab>'
let g:SuperTabMappingBackward = '<tab>'

" }}}
" Plugin: Ultisnips {{{

let g:UltiSnipsSnippetsDir = "~/.vim/my_snippet"
let g:UltiSnipsSnippetDirectories = ["ulti_snippet", "my_snippet"]
let g:UltiSnipsExpandTrigger = "<tab>"
let g:UltiSnipsJumpForwardTrigger = "<tab>"
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"

" }}}
" Plugin: Easy Align {{{

" start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <plug>(EasyAlign)
" start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <plug>(EasyAlign)

" verilog non-blocking auto align
inoremap <silent> <= <=<Esc>mzvip:EasyAlign/<=/<CR>`z$a<Space>

" customized setting mainly for verilog
" d: for aligning port/signal list with last space before ,;=)
let g:easy_align_delimiters = {
            \ '/': {
            \     'pattern':         '//\+\|/\*\|\*/',
            \     'delimiter_align': 'l',
            \     'ignore_groups':   ['!Comment'] 
            \     },
            \ ':': {
            \     'pattern':       ':',
            \     'left_margin':   1,
            \     'right_margin':  1,
            \     },
            \ '?': {
            \     'pattern':       '?',
            \     'left_margin':   1,
            \     'right_margin':  1,
            \     },
            \ '(': {
            \     'pattern':       '(',
            \     'left_margin':   1,
            \     'right_margin':  0,
            \   },
            \ ')': {
            \     'pattern':       ')',
            \     'left_margin':   0,
            \     'right_margin':  0,
            \   },
            \ 'd': {
            \     'pattern':      ' \ze\S\+\s*[,;=]',
            \     'left_margin':  0,
            \     'right_margin': 0
            \   }
            \ }

" }}}
" Plugin: CtrlP {{{

let g:ctrlp_map = '<C-p>'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_working_path_mode = 'ra'
let g:ctrlp_show_hidden = 0
let g:ctrlp_custom_ignore = {
            \ 'dir': '\v[\/]\.(git)$',
            \ 'file': '\v\.(DS_Store)$',
            \ }
let g:ctrlp_user_command = ['.git', 'git --git-dir=%s/.git ls-files -co --exclude-standard']

" Argument: focus, byfname, s:regexp, prv, item, nxt, marked
"           a:1    a:2      a:3       a:4  a:5   a:6  a:7
function! CtrlPMainStatus(...)
    let prv = '%#Comment# ' . a:4 . ' %*'
    let item = '%#PmenuSel# ' . (a:5 == 'mru files' ? 'mru' : a:5) . ' %*'
    let nxt = '%#Comment# ' . a:6 . ' %*'
    let dir = '%#Comment# « %*%4*' . fnamemodify(getcwd(), ':~') . '%* '

    " only output current mode and dir
    return '%#Comment# » %*' . item . '%#Comment# « ' . '%=%<' . dir
endfunction

" Argument: len
"           a:1
function! CtrlPProgressStatus(...)
    let len = '%#Function# ' . a:1 . ' %*'
    let dir = ' %=%<%#LineNr# ' . getcwd() . ' %*'
    return len . dir
endfunction

let g:ctrlp_status_func = {
            \ 'main': 'CtrlPMainStatus',
            \ 'prog': 'CtrlPProgressStatus'
            \ }

nnoremap gp :CtrlPBuffer<CR>

" }}}

" modeline
" vim:foldmethod=marker:foldmarker={{{,}}}:foldlevel=0:
